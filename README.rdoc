=What are Phidgets?

Phidgets are a set of "plug and play" building blocks for low cost USB sensing and control from your PC
available from http://www.phidgets.com. 

=Phidgets-FFI

This is a set of FFI bindings for the Phidgets library available for most platforms.
Currently, it only supports the devices available to me but it to but it supports them completely.
It also supports the manager, dictionary, logging, callbacks function perfectly, and there
are a set of idiomatic bindings that take the provided API and make it more accessible. Raw FFI
examples are in examples/ffi and the idiomatic versions are in examples/.

==Quick Start

To access the manager and see your attached devices:

  Phidgets::Manager.new do |manager|
    puts manager.devices.inspect
  end
  
  [{
    :type=>"PhidgetServo",
    :label=>"",
    :device_id=>:servo_1motor,
    :serial_number=>12345,
    :name=>"Phidget Servo Controller 1-motor",
    :device_class=>:servo,
    :version=>313
  }]

To access that servo controller and do something with the servo:

  Phidgets::ServoController.new(12345) do |controller|
    servo = controller.servos[0]

    controller.on_change do |servo, position, data|
      print "Moving servo #{servo.index} to #{position}\n"
    end
  
    max = servo.max
    10.times do
      servo.position = rand(max)
      sleep 1
    end
    servo.engaged = false
  end

==Dictionary

The Dictionary service is a web service that functions as a remote key/value store with optional persistence and change handlers.
There are two sleep variables that determine how long to wait after registering a handler, and how long to wait after getting/setting a key.
If handlers or keys are set too rapidly, the library will segfault. Also note that the keys appear to cause segfault if a space is used in the key.

  Phidgets::Dictionary.new do |dict|
    dict.on_error do |obj, code, reason|
      puts "Error (#{code}): #{reason}"
    end
    dict.on_connect do |obj|
      print "Connected!\n"
    end
    dict.on_disconnect do |obj|
      print "Disconnected!\n"
    end
    dict.on_error do |obj, code, reason|
      puts "Error (#{code}): #{reason}"
    end

    dict.on_change(/temp.*/) do |obj, key, val, reason|
        print "#{key}: #{val}\n" if reason != :unchanged
    end
    dict.on_change('switch') do |obj, key, val, reason|
      print "#{key} is now #{val == "1" ? 'on' : 'off'}\n" if reason != :unchanged
    end

    puts "Listening to: #{dict.listeners.inspect}"
    dict["temp_1"] = 15
    dict["temp_2"] = 20
    dict["temp_2"] = 20
    dict["switch_a"] = 1
    dict["switch_b"] = 1
    dict["switch_b"] = 0
  end

==Logging

Logging can be accomplished by either accessing the C library directly or using the idiomatic method.
There are additional examples of each in the examples/ directory.

  Phidgets::Log.enable(:verbose, nil)
  Phidgets::Log.info('identifier', 'message')
  Phidgets::Log.error('identifier', 'message')
  Phidgets::Log.disable

==Notes

Again, note that not every device is here. I'm more than happy to add support for it
but I'll need a test device to make sure it works ;)

P.S. Seriously, contact me if you want my mailing address to send me a device you'd like this library to support.